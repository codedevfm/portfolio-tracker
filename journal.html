---
layout: default
title: Journal
---

<style>
  /* This style block is designed to work within a Jekyll layout.
    It makes the journal container fill the available vertical space.
  */
  #journal-container {
    /* Using vh (viewport height) units can be tricky inside layouts.
      A flexbox approach is often more robust. We assume the parent
      container of this page allows its children to grow.
      For a simpler approach, you could try a fixed height:
      height: 85vh; 
    */
    display: flex;
    flex-direction: column;
    height: 85vh; /* Adjust this value as needed to fit your layout */
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem 1rem 1rem;
  }

  #journal-table {
    flex-grow: 1; /* Allows the grid to fill the container's height */
    width: 100%;
  }
</style>

<h1 class="text-2xl font-bold mb-4">Journal</h1>

<!-- AG Grid CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community/styles/ag-grid.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community/styles/ag-theme-alpine.css" />

<!-- Supabase -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<!-- AG Grid JS -->
<script src="https://cdn.jsdelivr.net/npm/ag-grid-community@30.2.0/dist/ag-grid-community.min.js"></script>

<!-- The main container for the AG Grid table -->
<div id="journal-container">
  <div id="journal-table" class="ag-theme-alpine"></div>
</div>

<script>
  console.log("‚úÖ Script started loading");

  const tableEl = document.querySelector("#journal-table");

  function logWithTimestamp(...args) {
    const now = new Date().toISOString();
    console.log(`[${now}]`, ...args);
  }
  
  // --- Supabase and Grid Configuration ---

  const supabaseUrl = "https://dibljhwqxxsvdwrzhchk.supabase.co";
  const supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRpYmxqaHdxeHhzdmR3cnpoY2hrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDkyMzgwOTAsImV4cCI6MjA2NDgxNDA5MH0.qcbOKHlDjua_ijVa_3mvnfjbZCl1wROJDtZ4naeZZko";
  const { createClient } = window.supabase;
  const supabase = createClient(supabaseUrl, supabaseKey);

  // A mock user ID. In a real app, this would come from an authentication system.
  const USER_ID = "00000000-0000-0000-0000-000000000000";
  const ACTIVITY_TYPES = ["Buy", "Sell", "Dividend", "Split", "Interest", "Fee", "Other"];

  let gridApi;

  // AG Grid options
  const gridOptions = {
    getRowId: params => params.data.id,
    columnDefs: [
      { field: "id", hide: true, editable: false },
      {
        field: "activity_type",
        editable: true,
        cellEditor: "agSelectCellEditor",
        cellEditorParams: { values: ACTIVITY_TYPES },
        valueFormatter: params => params.value || "",
      },
      { field: "symbol", editable: true },
      { field: "trade_date", editable: true, cellEditor: 'agDateCellEditor' },
      { field: "quantity", editable: true, valueParser: "Number(params.newValue)", cellClass: "ag-right-aligned-cell" },
      { field: "price", editable: true, valueParser: "Number(params.newValue)", cellClass: "ag-right-aligned-cell" },
      { field: "fee", editable: true, valueParser: "Number(params.newValue)", cellClass: "ag-right-aligned-cell" },
      { field: "note", editable: true },
      { field: "inserted_at", editable: false, headerName: 'Created At' },
    ],
    defaultColDef: {
      filter: true,
      sortable: true,
      resizable: true,
      flex: 1,
      minWidth: 120,
    },
    pagination: false,
    animateRows: true,
    singleClickEdit: true,
    stopEditingWhenCellsLoseFocus: true,
    onGridReady: (params) => {
      gridApi = params.api;
      gridApi.sizeColumnsToFit();
      window.addEventListener('resize', () => gridApi.sizeColumnsToFit());
      loadData("initial");
    },
    onCellValueChanged: async (params) => {
      const rowData = { ...params.data };

      if (!rowData.id) {
        rowData.id = crypto.randomUUID();
      }
      if (!rowData.user_id) {
        rowData.user_id = USER_ID;
      }
      if (!rowData.inserted_at) {
        rowData.inserted_at = new Date().toISOString();
      }
      
      rowData.updated_at = new Date().toISOString();

      logWithTimestamp("‚¨ÜÔ∏è Upserting row to database:", rowData);

      const { error } = await supabase
        .from("journal")
        .upsert([rowData], { onConflict: "id" });

      if (error) {
        logWithTimestamp("‚ùå Supabase upsert error:", error.message);
      } else {
        logWithTimestamp("‚úÖ Row saved to Supabase successfully.");
        fetchAndUpdateRowById(rowData.id, 'after-upsert');
      }
    },
    onRowDataUpdated: (params) => {
        const rowCount = gridApi.getDisplayedRowCount();
        if (rowCount === 0) {
             gridApi.applyTransaction({ add: [{ user_id: USER_ID }] });
             return;
        }
        const lastRowNode = gridApi.getDisplayedRowAtIndex(rowCount - 1);
        const lastRowData = lastRowNode.data;
        if (lastRowData && lastRowData.activity_type) {
            gridApi.applyTransaction({ add: [{ user_id: USER_ID }] });
        }
    },
  };

  /**
   * Updates or adds a row in the grid.
   */
  function updateRowInGrid(updatedRow) {
    if (!gridApi) return;
    const nodeToUpdate = gridApi.getRowNode(updatedRow.id);
    if (nodeToUpdate) {
      nodeToUpdate.setData(updatedRow);
    } else {
      gridApi.applyTransaction({ add: [updatedRow] });
    }
  }

  /**
   * Loads all journal entries for the current user.
   */
  async function loadData(source = "manual") {
    if (!gridApi) {
      logWithTimestamp("gridApi is not initialized.");
      return;
    }

    logWithTimestamp(`[${source}] ‚è≥ Loading data...`);
    const { data, error } = await supabase
      .from("journal")
      .select("*")
      .eq("user_id", USER_ID)
      .order("trade_date", { ascending: false, nullsFirst: false });

    if (error) {
      logWithTimestamp(`[${source}] ‚ùå Supabase fetch error:`, error.message);
      return;
    }

    logWithTimestamp(`[${source}] ‚¨áÔ∏è Received ${data.length} rows.`);
    
    gridApi.setRowData(data);
    gridApi.applyTransaction({ add: [{ user_id: USER_ID }] });
  }

  /**
   * Fetches a single row by ID to update the grid.
   */
  async function fetchAndUpdateRowById(id, source = "manual") {
    const { data, error } = await supabase
      .from("journal")
      .select("*")
      .eq("id", id)
      .single();

    if (error || !data) {
      logWithTimestamp(`[${source}] ‚ùå Could not fetch row id=${id}:`, error?.message || "Not found");
      return;
    }
    
    updateRowInGrid(data);
  }
  
  // --- Initialization and Real-time Subscription ---

  // Ensure AG Grid is ready before creating the grid
  const initializeGrid = () => {
    if (typeof agGrid === "undefined" || !document.querySelector("#journal-table")) {
      logWithTimestamp("AG Grid or table element not ready, retrying...");
      setTimeout(initializeGrid, 100);
      return;
    }
    
    new agGrid.Grid(document.querySelector("#journal-table"), gridOptions);

    // Set up Supabase real-time subscription
    supabase
      .channel("journal_changes")
      .on("postgres_changes", { event: "*", schema: "public", table: "journal" }, (payload) => {
        logWithTimestamp("üì° Realtime notification:", payload.eventType);

        const id = payload.new?.id || payload.old?.id;
        if (!id) return;
        
        if (payload.new?.user_id !== USER_ID && payload.old?.user_id !== USER_ID) {
            return;
        }

        if (payload.eventType === "DELETE") {
          const nodeToRemove = gridApi.getRowNode(id);
          if (nodeToRemove) {
            gridApi.applyTransaction({ remove: [nodeToRemove.data] });
          }
        } else if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
          updateRowInGrid(payload.new);
        }
      })
      .subscribe((status, err) => {
          if (status === 'SUBSCRIBED') {
              logWithTimestamp('‚úÖ Subscribed to real-time changes!');
          } else {
              logWithTimestamp('‚ùå Failed to subscribe:', err);
          }
      });
  };
  
  // Start the initialization process
  initializeGrid();

</script>
